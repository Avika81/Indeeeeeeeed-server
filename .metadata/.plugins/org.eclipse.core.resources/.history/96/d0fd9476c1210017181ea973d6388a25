package Network;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

import Network.Spell.Effect;

import java.lang.Math;

/** Manages a Battle */
public class GameManager{
	
	public final static float BOARD_EDGE_Y         = 11f;
	public final static float BOARD_EDGE_X         = 4.5f;
	public final static float LANE_CENTER_X        = 3.41f;
	public final static float GATE_SIZE            = 0.5f;
	public final static float PROXIMITY_DELTA      = 0.05f;
	
	static final float MINION_SHIFT                = 2f;
	static final int LEFT_FLAG_KEY                 = -1;
	static final int RIGHT_FLAG_KEY                = -2;
	static final int ENEMY_KING_KEY                = -3;
	static final Vector2 KING_0_START_POS          = new Vector2(0, BOARD_EDGE_Y);
	static final Vector2 LANE_CENTER_LEFT          = new Vector2(LANE_CENTER_X, 0);
	static final Vector2 LANE_CENTER_RIGHT         = new Vector2(-LANE_CENTER_X, 0);
	static final float DELTA_LOOKAT_FLAG           = 0.5f;
	
	static final long timeBeforeRemove             = 3000;
	
	public static final long FIRST_GM_UPDATE       = 100;
	//public static final long CREATURES_UPDATE_DELTA_TIME = 50;	
	public static final int DECK_SIZE              = 31;
	public static final int NUM_CARD_INITIAL       = 4;
	public static final long TIME_BETWEEN_DRAWS    = 9000;
	public static final long TIME_BETWEEN_MINIONS  = 2000000;
	public static final float SPATIAL_SCALE_FACTOR = 0.2f;	
	public static final int MANA_INITIAL           = 0;	
	public static final int MANA_GROWTH_TIME       = 2000;
	
	public static final long DEPLOY_TIME               = 1500;
	public static final long FIRST_UPDATE_TIME         = -2000;
    public static final long PACKAGE_UPDATE_DELTA_TIME = 1000;
    public static final long GAME_UPDATE_DELTA_TIME    = 100;
    public static final long END_GAME_TIME             = 300000;
    public static final long TIME_BUFFER               = 800;
	
	int numCreaturesAdded             = 0;
	int numSpellsAdded                = 0;
	
	public boolean gameEnded          = false;
	
	// creature or spell id
	public int cr_sp_id = 0;
	
	public long startGameTime         = -1;
	long clientsTime = 0;
	long timeRunningAtServer;
	long timeRunningAtClients;
	public long gameTime              = -1;
	public long lastUpdateTime;
	public long nextUpdateTime        = 0;
	public long nextUpdateServerTime  = 0;
	public long timeAtClient          = 0;
	public Boolean sentKings          = false;
	public boolean firstHandDrawn     = false;
	final long gameStartDelay         = 2000;
	final long TimeOfFirstHandDrawing = -500;
	
	boolean startClockSent            = false;  

	String creaturesDataSelf          = "";
	String creaturesDataOther         = "";
	String spellsDataSelf             = "";
	String spellsDataOther            = "";
    
    long clockDifference              = 0;
	
	// static final String ScaleFactor = 0.2f;

	//public HashMap<String, Player> players;
	public ArrayList<Player> players;
	
	//long schedule_Creatures_Update;
	
	public GameManager(ArrayList<Player> players) 
	{
		this.players = players;
	}

	public void start() 
	{
		System.out.println("GameManager Starting");
		
		//sendGameManagerParams();
		
		players.get(0).gameManager = this;
		players.get(1).gameManager = this;
		
		createKings();
		
		initMasteriesEffects();		
		
		drawFirstHand();							
				
		gameTime = 0;
		
		addToPlayersData();
		
		sendVillainManaGrowth();
		
		players.get(0).inGame = true;
		players.get(1).inGame = true;	
		
		players.get(0).sendData(Constants.GAME_STARTING);
		players.get(1).sendData(Constants.GAME_STARTING);		
	}
	
	public void update() 
	{
		removeDeadCreatures();
		removeFinishedSpells();
		
		//addMana();
		drawCards();
		spawnMinions();
		
		if(numCreaturesAdded>0)
		{
			System.out.println("1. adjustCreaturesLocations");
			adjustCreaturesLocations();
			System.out.println("2. adjustCreaturesLocations");
		}
			
			
		//activateSpells();
		
		//if(numSpellsAdded > 0)
		//	adjustSpellsLocations(); // currently not implemented
		
		setCreatureTargets();
		
		creaturesMove();
		System.out.println("3. adjustCreaturesLocations");
		adjustCreaturesLocations();
		System.out.println("4. adjustCreaturesLocations");		
		setCreatureTargets();		
				
		creaturesAttack();
		
		creaturesApplyDmgAndSE();
		
		// applyStuns();
		
		updateSpells();
		applyCreaturesHealthRegen();
		
		//adjustCreaturesLocations();
		setCreatureTargets();
		
		setSpellStatuses();
	}
	
	void initMasteriesEffects()
	{
		initMinionTime();
		initDrawTime();
	}
	
	void initMinionTime()
	{
		for(Player player : players)
		{
			player.effectiveTimeBetweenMinions = GameManager.TIME_BETWEEN_MINIONS;
			player.timeOfNextMinion = player.effectiveTimeBetweenMinions;
		}
	}
	
	void initDrawTime()
	{
		for(Player player : players)
		{
			player.effectiveTimeBetweenDraws = GameManager.TIME_BETWEEN_DRAWS;
			player.timeOfNextDraw = player.effectiveTimeBetweenDraws;
		}
	}
	
	void sendVillainManaGrowth()
	{
		players.get(0).sendData(
				Constants.VILLAIN_MANA_GROWTH_TIME +
				Constants.EQUALS +
				players.get(1).effectiveManaGrowthTime);
		
		players.get(1).sendData(
				Constants.VILLAIN_MANA_GROWTH_TIME +
				Constants.EQUALS +
				players.get(0).effectiveManaGrowthTime);
	}
	
//	public void sendStartClocks(long clockDifference)
//	{
//		sendStartClock(players.get(0), -clockDifference/2);
//		sendStartClock(players.get(1), clockDifference/2);
//		//long meanPing = (Long)Math.floor((players.get(0).ClockTime + players.get(1).ClockTime)/2);
//		startGameTime = Main.serverTime + gameStartDelay;
//		nextUpdateTime = FIRST_UPDATE_TIME;
//		schedule_Check_Confirmation_For_Update_Client = startGameTime + FIRST_UPDATE_TIME;
//		//System.out.println("Schedule: " + schedule_Check_Confirmation_For_Update_Client);
//	}
//	
//	public void sendStartClock(Player player, long clockDifference)
//	{
//		player.gotGameLoaded = false;		
//		String msg = Constants.START_CLOCK + Constants.FIELD_SEPERATOR + (player.clock + gameStartDelay + clockDifference);
//		player.sendData(msg);
//	}
//	
//	public void calculateClockDifference()
//	{
//		players.get(0).gotGameLoaded = false;
//		players.get(1).gotGameLoaded = false;	
//		clockDifference = players.get(0).ClockTime -  players.get(1).ClockTime;
//		sendStartClocks(clockDifference);
//	}
	
//	public void AskClock()
//	{
//		players.get(0).gotClock = false;
//		players.get(1).gotClock = false;		
//		String msg = Constants.CLOCK;
//		players.get(0).sendData(msg);
//		players.get(1).sendData(msg);
//	}

	void updateSpells() 
	{
    	for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		playerApplySpellsEffect(player.spells);
    	}
	}

    void setSpellStatuses()
    {
    	for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		setPlayerSpellStatuses(player.spells);
    	}
    }

    public void setPlayerSpellStatuses(Map<Integer, Spell> spells) {
	    Iterator<Map.Entry<Integer, Spell>> it = spells.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer, Spell> pair = it.next();
	        //int CreatureId = pair.getKey();
	    	Spell spell = pair.getValue();
	        if(gameTime > (spell.timeOfCasting + DEPLOY_TIME + spell.duration))
	        {
	        	if(Constants.clientTimingDebug)
        			System.out.println("Timing: Spell changed to FIN with ID: " + spell.id + " at gameTime: " + gameTime);
	        	spell.status = Spell.Status.FIN;
	        	//System.out.println("@@@ setPlayerSpellStatuses: " + spell.status + " GameTime: " + gameTime);
	        }
	        if ((spell.status == Spell.Status.INIT) 
        			&& ((gameTime - spell.timeOfCasting) > DEPLOY_TIME))
        	{
        		spell.status = Spell.Status.ACT;
        		spell.activationTime = gameTime;
        		//System.out.println("###setPlayerSpellStatuses: " + spell.status + " GameTime: " + gameTime);
        		if(Constants.clientTimingDebug)
        			System.out.println("Timing: Spell activated in server with ID: " + spell.id + " at gameTime: " + gameTime);
        	}
	    }
	}
	
	void removeDeadCreatures()
	{
		for(Player player : players)
		{
			ArrayList<Integer> creaturesIdToRemove = new ArrayList<Integer>(); 
			
			Iterator<Map.Entry<Integer,Creature>> it = player.creatures.entrySet().iterator();
		    while (it.hasNext()) {
		    	Map.Entry<Integer,Creature> pair = it.next();
		        //int CreatureId = pair.getKey();
		        Creature creature = pair.getValue();
			    
		        if(creature.status.equals(Creature.Status.DEAD) && (gameTime - creature.timeOfDeath) > timeBeforeRemove)
		        	creaturesIdToRemove.add(creature.id);		
		    }
		    for(int creatureId : creaturesIdToRemove)
		    	player.creatures.remove(creatureId);		    
		}
	}
	
	void removeFinishedSpells()
	{
		for(Player player : players)
		{
			ArrayList<Integer> spellsIdToRemove = new ArrayList<Integer>(); 
			
			Iterator<Map.Entry<Integer,Spell>> it = player.spells.entrySet().iterator();
		    while (it.hasNext()) {
		    	Map.Entry<Integer,Spell> pair = it.next();
		        //int SpellId = pair.getKey();
		    	Spell spell = pair.getValue();
			    
		        if(spell.status.equals(Spell.Status.FIN))
		        	spellsIdToRemove.add(spell.id);		
		    }
		    for(int spellId : spellsIdToRemove)
		    	player.spells.remove(spellId);		    
		}
	}
	
//	public void addCreaturesToGM() 
//	{
//		if(Main.serverTime > schedule_Creatures_Update)
//		{
//			MoveCreaturesToGM();// timing
//			schedule_Creatures_Update += CREATURES_UPDATE_DELTA_TIME;
//		}
//	}
	
	public void checkConfirmationAndUpdate()
	{
		//System.out.println("Check Confirmation for nextUpdateTime: " + nextUpdateTime);
		if(checkNextConfirmedTime())
		{
			update();
			addToPlayersData();
			sendDataToPlayers();			
			lastUpdateTime = gameTime;
		}
	}

	int findClosesEnemy(int creatureIndex, ArrayList<CreatureDynamicData> creaturesData)
	{
		float minDistance = 10000f;
		int indexClosestCreature = -1;
		for(int i=0; i<creaturesData.size();i++)
		{
			float softDistance = creaturesData.get(i).softRadius + creaturesData.get(creatureIndex).softRadius;
			float oldDistance = getDistance(i,creatureIndex, creaturesData);
			if((creaturesData.get(creatureIndex).player != creaturesData.get(i).player)
					&&(oldDistance<softDistance)
					&&(oldDistance<minDistance))
			{
				minDistance = oldDistance;
				indexClosestCreature = i;
			}
		}
		return indexClosestCreature;	
	}
	
	void adjustCreaturesLocations()
    {
		ArrayList<CreatureDynamicData> creaturesData = getCreaturesLocations();
		adjustLocations(creaturesData);
    }
	
	void adjustSpellsLocations()
	{
		// TODO - determine if needed and if so implement
	}
	
	void adjustLocations(ArrayList<CreatureDynamicData> creaturesData) 
	{
		boolean continueProximityCorrection = true;
		int minNumOfItertions = 60;
		int numOfIterations = 0;
		
		//System.out.println("Start adjustLocations: " + crossInteractions);
		while(continueProximityCorrection && numOfIterations<minNumOfItertions)
		{
			continueProximityCorrection = false;
			ArrayList<CreatureDynamicData> newCreaturesData = findNewLocations(creaturesData);
			newCreaturesData = adjustLocationsToBoarders(newCreaturesData) ;
			
			//newCreaturesData = adjustLocationsToBoarders(newCreaturesData);
			
			//newCreaturesData = avoidPushBack(creaturesData, newCreaturesData, crossInteractions);
			
			creaturesData = CreatureDynamicData.createArrayListClone(newCreaturesData);
			
			continueProximityCorrection = checkIfFinished(creaturesData);
			
			numOfIterations++;
		}
		//System.out.println("End adjustLocations " + " Iterations: " + numOfIterations);
		setLocationsCreatures(creaturesData);
	}

	boolean checkIfFinished(ArrayList<CreatureDynamicData> creaturesData)
	{
		boolean continueProximityCorrection = false;
		for(int i=0; i<creaturesData.size()-1;i++)
		{
			for(int j=i+1; j<creaturesData.size();j++)
			{
    			float distance = getDistance(i, j, creaturesData);
				if(distance < (creaturesData.get(i).hardRadius + creaturesData.get(j).hardRadius)) 
					continueProximityCorrection = true;
    		}
		}
		return continueProximityCorrection;
	}

	ArrayList<CreatureDynamicData> avoidPushBack(ArrayList<CreatureDynamicData> creaturesData, ArrayList<CreatureDynamicData> newCreaturesData, boolean crossInteractions) 
	{
		ArrayList<CreatureDynamicData> correctedCreaturesData = CreatureDynamicData.createArrayListClone(newCreaturesData);
		if(!crossInteractions)
		{
			for(int i=0; i<creaturesData.size();i++)
    		{
				boolean pushedBackFromEnemy = false;
				//boolean pushedTowardsEnemy = false;
				int indexClosestEnemy = findClosesEnemy(i, creaturesData);
				if(indexClosestEnemy>0)
				{
					float softDistance = creaturesData.get(i).softRadius + creaturesData.get(indexClosestEnemy).softRadius;
					//float hardDistance = creaturesData.get(i).hardRadius + creaturesData.get(indexClosestEnemy).hardRadius;
					float oldDistance = getDistance(i , indexClosestEnemy , creaturesData);
					float distanceFromEnemysOldLocation = 
							Vector2.magnitude(Vector2.substract( creaturesData.get(indexClosestEnemy).position , newCreaturesData.get(i).position));
    				
//					boolean g = distanceFromEnemysOldLocation>oldDistance;
//					boolean h = oldDistance<softDistance;
					
					if((distanceFromEnemysOldLocation>oldDistance) && (oldDistance<softDistance))
						pushedBackFromEnemy = true;
					
					if(pushedBackFromEnemy)
					{
						for(int j=0; j<creaturesData.size();j++)
		    			{
		    				softDistance = creaturesData.get(i).softRadius + creaturesData.get(j).softRadius;
	    					oldDistance = getDistance(i , j , creaturesData);
		    				if((creaturesData.get(j).player != creaturesData.get(i).player)
		    						&& (oldDistance<softDistance)
		    						&& (j!=indexClosestEnemy))
		    				{
		    					distanceFromEnemysOldLocation = 
		    							Vector2.magnitude(Vector2.substract(creaturesData.get(j).position, newCreaturesData.get(i).position));
//		    					if(distanceFromEnemysOldLocation<oldDistance)
//		    						pushedTowardsEnemy = true;
		    				}
		    			}
					}

					if(pushedBackFromEnemy) //  && !pushedTowardsEnemy
					{
	    				correctedCreaturesData.set(i, new CreatureDynamicData(creaturesData.get(i)));
					}
	    		}
    		}
		}
		return correctedCreaturesData;
	}

	ArrayList<CreatureDynamicData> adjustLocationsToBoarders(ArrayList<CreatureDynamicData> newCreaturesData) 
	{
		for(int i=0; i<newCreaturesData.size(); i++)
		{
			newCreaturesData.get(i).position = checkBorders(newCreaturesData.get(i).position);
		}
		return newCreaturesData;
	}

	ArrayList<CreatureDynamicData> findNewLocations(ArrayList<CreatureDynamicData> creaturesData) 
	{
		Vector2[][] proximityMatrix = createProximityMatrix(creaturesData);		
		ArrayList<CreatureDynamicData> newCreaturesData = CreatureDynamicData.createArrayListClone(creaturesData);
		for(int i=0; i<creaturesData.size() - 1; i++)
		{
			for(int j=i+1; j<creaturesData.size(); j++)
			{
				Vector2 force = getForce(i , j, proximityMatrix, creaturesData);

				float friction_i = 1;
				if(newCreaturesData.get(i).status.equals(Creature.Status.ATK))
					friction_i = 1/3;
				friction_i /= newCreaturesData.get(i).mass;
				float friction_j = 1;
				if(newCreaturesData.get(j).status.equals(Creature.Status.ATK))
					friction_j = 1/3;
				friction_j /= newCreaturesData.get(j).mass;
				
				float rel_i = friction_i / (friction_i + friction_j);
				float rel_j = friction_j / (friction_i + friction_j);
				
				if (!newCreaturesData.get(i).immobile || !newCreaturesData.get(i).initiallyLocated)
				{		
					Vector2 shift = Vector2.multiplyByScalar(force , rel_i);
					newCreaturesData.get(i).position =  Vector2.add(newCreaturesData.get(i).position,  shift);
				}
				if (!newCreaturesData.get(j).immobile || !newCreaturesData.get(j).initiallyLocated)
				{
					Vector2 shift = Vector2.multiplyByScalar(force , rel_j);
					newCreaturesData.get(j).position = Vector2.substract(newCreaturesData.get(j).position, shift);
				}
			}
		}
		return newCreaturesData;
	}

	Vector2 checkBorders(Vector2 pos)
	{
		pos.x = checkCoord(pos.x, BOARD_EDGE_X);
		pos.y = checkCoord(pos.y, BOARD_EDGE_Y);
		return pos;
	}
	
	float checkCoord(float x, float boardEdge)
	{
		if(x > boardEdge)
			x = boardEdge;
		else if(x < -boardEdge)
			x = -boardEdge;
		return x;
	}
	
	void setLocationsCreatures(ArrayList<CreatureDynamicData> allCreatures) 
	{
		for(int i = 0; i < allCreatures.size(); i++)
		{
			int id = allCreatures.get(i).id;
			Player player = players.get(0);
			if(player.creatures.containsKey(id))
			{
				Creature creature = player.creatures.get(id);
				creature.pos = allCreatures.get(i).position;
				creature.initiallyLocated = true;
			}
			else
			{
				player = players.get(1);
				Creature creature = player.creatures.get(id);
				creature.pos = allCreatures.get(i).position;
				creature.initiallyLocated = true;
			}
	    }
	}
	
	ArrayList<CreatureDynamicData> getCreaturesLocations()
	{
		ArrayList<CreatureDynamicData> allCreatures = new ArrayList<CreatureDynamicData>();
		for(int i=0; i<players.size(); i++)
		{
			Player player = players.get(i);
			allCreatures.addAll(getPlayerCreatures(player.creatures));
		}
		return allCreatures;
	}
	
	ArrayList<CreatureDynamicData> getPlayerCreatures(Map<Integer, Creature> creatures) 
    {
		ArrayList<CreatureDynamicData> playerCreatures = new ArrayList<CreatureDynamicData>();
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer, Creature> pair = it.next();
	        int CreatureId = (int)pair.getKey();
	        Creature creature = (Creature)creatures.get(CreatureId);
			creature.player.creatures.put(creature.id, creature);
			CreatureDynamicData creatureData = new CreatureDynamicData(creature);
			playerCreatures.add(creatureData); 
	    }
	    return playerCreatures;
	}
	
	Vector2 getForce(int i, int j, Vector2[][] proximityMatrix, ArrayList<CreatureDynamicData> creaturesData)
	{
		Vector2 force = null;
		Vector2 forceDirection = Vector2.normalize(proximityMatrix[i][j]);
		float soft1 = creaturesData.get(i).softRadius;
		float soft2 = creaturesData.get(j).softRadius;
		float distance = getDistance(i, j, creaturesData);
		float maxForceAmplitude;
		if(distance < soft1 + soft2)
			maxForceAmplitude = (soft1 + soft2 - distance) / 2;
		else
			maxForceAmplitude = 0;
		float forceAmplitude = maxForceAmplitude / 4;
		force = Vector2.multiplyByScalar(forceDirection, forceAmplitude);
		
		return force; 
	}
	
	float getDistance(int i, int j, ArrayList<CreatureDynamicData> creaturesData)
	{
		return Vector2.magnitude(Vector2.substract( creaturesData.get(i).position, creaturesData.get(j).position));
	}
    
	Vector2[][] createProximityMatrix(ArrayList<CreatureDynamicData> creaturesData)
    {	
    	int n = creaturesData.size();
    	Vector2[][] proximityMatrixTemp = new Vector2[n+1][n+1];
    	
    	for(int i=0; i<n; i++)
    	{
    		for(int j=i+1; j<n; j++)
        	{
    			Vector2 vector = Vector2.substract(creaturesData.get(i).position, creaturesData.get(j).position);
    			if(Vector2.magnitude(vector) < PROXIMITY_DELTA)
    			{
    				vector = Vector2.multiplyByScalar(Vector2.left(), PROXIMITY_DELTA);
    			}
    			proximityMatrixTemp[i][j] = vector;
        	}
    	}
    	return proximityMatrixTemp;
    }
        
    void adjustPositions(ArrayList<CreatureDynamicData> creaturesData)
    {
    	for(int i=0; i<creaturesData.size(); i++)
    	{
    		receiveData(i, creaturesData);
    	}
    }
    
    /*Used in adjustPosition*/
    void receiveData(int i , ArrayList<CreatureDynamicData> creaturesData)
    {
		CreatureDynamicData creatureData = creaturesData.get(i);
		Player player = creatureData.player;
		int id = creatureData.id;
		Creature creature = player.creatures.get(id);
		creature.pos = creatureData.position;
    }

    void createKings() 
	{
    	Player player = players.get(0);
    	ArrayList<String> segments = new ArrayList<>();
    	segments.add(Constants.CREATURE_KEY);
    	segments.add(Constants.CR_KING);
    	Creature creature = createCreature(segments, player);
    	player.creatures.put(creature.id, creature);
    	player.king = creature;
    	player = players.get(1);
    	creature = createCreature(segments, player);
    	player.creatures.put(creature.id, creature);
    	player.king = creature;
    	sentKings = true;
    	//System.out.println("b. King time of casting: " + creature.timeOfCasting);
	}

    int addCreaturesToLists() // in GR
    {		
    	int numCreatures = 0;
		for(int i=0; i<players.size(); i++)
		{
			Player player = players.get(i);
			numCreatures += addCreaturesPlayer(player);
		}
		
		return numCreatures;
	}
    
	int addCreaturesPlayer(Player player) // in GR
	{		
		for(int i=0; i<player.creaturesToAddGM.size(); i++)
		{			
			Creature creature = player.creaturesToAddGM.get(i);
			//System.out.println("Adding creature from creaturesToAddGM of player: " + player.playerIndex + " ID: " + creature.id);
			player.creatures.put(creature.id, creature);
			
//			if(player.confirmedTimes == null)
//				System.out.println("player.confirmedTimes == null");
//			System.out.println("creature.timeOfSending: " + creature.timeOfSending + " ID: " + creature.id);
//			System.out.println("player.confirmedTimes.get(creature.timeOfSending): " + player.confirmedTimes.get(creature.timeOfSending));
			if(player.confirmedTimes.containsKey(creature.timeOfSending))
				player.confirmedTimes.replace(creature.timeOfSending, player.confirmedTimes.get(creature.timeOfSending)-1);
//			System.out.println("(players: " + player.playerIndex + " confirmedTimes (CR): " + player.confirmedTimes.get(creature.timeOfSending) + " for nextUpdateTime: " + nextUpdateTime);
		}
		int size = player.creaturesToAddGM.size();
//		System.out.println("Clearing creaturesToAddGM. Size=: " + size);
//		if(size>0)
//			System.out.println("First creature ID: " + player.creaturesToAddGM.get(0));
		
		player.creaturesToAddGM.clear();

		return size;
	}
	
    int addSpellsToLists() // in GR
    {		
    	int numSpells = 0;
		for(int i=0; i<players.size(); i++)
		{
			Player player = players.get(i);
			numSpells += addSpellsPlayer(player);
		}		
		return numSpells;
	}
    
	int addSpellsPlayer(Player player) // in GR
	{		
		for(int i=0; i<player.spellsToAddGM.size(); i++)
		{
			//System.out.println("Adding spell from spellsToAddGM of player: " + player.playerIndex); // ???
			Spell spell = player.spellsToAddGM.get(i);
			player.spells.put(spell.id, spell);
			
//			if(player.confirmedTimes == null)
//				System.out.println("player.confirmedTimes == null");
//			System.out.println("spell.timeOfSending: " + spell.timeOfSending);
//			System.out.println("player.confirmedTimes.get(spell.timeOfSending): " + player.confirmedTimes.get(spell.timeOfSending));
			if(player.confirmedTimes.containsKey(spell.timeOfSending))
				player.confirmedTimes.replace(spell.timeOfSending, player.confirmedTimes.get(spell.timeOfSending)-1);
//			System.out.println(
//					"(players: " + player.playerIndex +
//					" confirmedTimes (CR): " + player.confirmedTimes.get(spell.timeOfSending) +
//			" for nextUpdateTime: " + nextUpdateTime);
		}
		int size = player.spellsToAddGM.size();
		player.spellsToAddGM.clear();

		return size;
	}
//
//	public boolean checkNextConfirmedTime()
//	{
//		boolean updateConfirmed = false;
//		timeAtClient = ServerMain.serverTime - startGameTime;
//		
//		//System.out.println("nextUpdateTime :" + nextUpdateTime);
//		if(Constants.serverTimingDebug)
//		{
//			if(players.get(0).confirmedTimes.containsKey(nextUpdateTime))
//				System.out.println(
//						"(player: " + players.get(0).playerIndex + " confirmedTimes: " + players.get(0).confirmedTimes.get(nextUpdateTime) + " for nextUpdateTime: " + nextUpdateTime);
//			if(players.get(1).confirmedTimes.containsKey(nextUpdateTime))
//				System.out.println(
//						"(player: " + players.get(1).playerIndex + " confirmedTimes: " + players.get(1).confirmedTimes.get(nextUpdateTime) + " for nextUpdateTime: " + nextUpdateTime);
//		}
//		boolean player0Confirmed = players.get(0).confirmedTimes.containsKey(nextUpdateTime)
//				&& (players.get(0).confirmedTimes.get(nextUpdateTime)==0);
//		boolean player1Confirmed = players.get(1).confirmedTimes.containsKey(nextUpdateTime)
//				&& (players.get(1).confirmedTimes.get(nextUpdateTime)==0);
//		long timeLeftUntilClientsTime = (nextUpdateTime + DEPLOY_TIME) - timeAtClient;
//		boolean allowOneSidedUpdate = (timeAtClient > DEPLOY_TIME - TIME_BUFFER) && startClockSent;
//		
//		if((player0Confirmed && player1Confirmed) || 
//				(allowOneSidedUpdate && (timeLeftUntilClientsTime <= TIME_BUFFER)))
//		{
//			if(Constants.serverTimingDebug)
//			{
//				System.out.println("nextUpdateTime: " + nextUpdateTime);
//				System.out.println("timeAtClient: " + timeAtClient);
//				System.out.println("allowOneSidedUpdate: " + allowOneSidedUpdate);
//				System.out.println("timeLeftUntilClientsTime: " + timeLeftUntilClientsTime);
//				if(player0Confirmed && player1Confirmed)
//					System.out.println("(Update: Both players have confirmed: " + nextUpdateTime);
//				else
//					System.out.println("Update: At least one player has not confirmed Time: " + nextUpdateTime);
//			}
//				
//			if(!player0Confirmed)
//			{
//				moveToNonConfirmed(players.get(0));
//			}
//			if(!player1Confirmed)
//			{
//				moveToNonConfirmed(players.get(1));
//			
//			}
//			
//			players.get(0).confirmedTimes.remove(nextUpdateTime);
//			players.get(1).confirmedTimes.remove(nextUpdateTime);
//			
//			updateConfirmed = updateGameTime();
//		}
//		return updateConfirmed;
//	}
//	
	public boolean checkNextConfirmedTime()
	{
		boolean updateConfirmed = false;
		timeAtClient = ServerMain.serverTime - startGameTime;
		
		long timeLeftUntilClientsTime = (nextUpdateTime + DEPLOY_TIME) - timeAtClient;
		boolean allowUpdate = (timeAtClient > DEPLOY_TIME - TIME_BUFFER) && startClockSent;
		
		if(allowUpdate && (timeLeftUntilClientsTime <= TIME_BUFFER))
		{
			if(Constants.serverTimingDebug)
			{
				System.out.println("nextUpdateTime: " + nextUpdateTime);
				System.out.println("timeAtClient: " + timeAtClient);
				System.out.println("allowOneSidedUpdate: " + allowUpdate);
				System.out.println("timeLeftUntilClientsTime: " + timeLeftUntilClientsTime);
			}
			updateConfirmed = updateGameTime();
		}
		return updateConfirmed;
	}
	
	void moveToNonConfirmed(Player nonConfirmedPlayer)
	{
		if(nonConfirmedPlayer.confirmedTimes.containsKey(nextUpdateTime))
			nonConfirmedPlayer.nonConfirmedTimes.add(nextUpdateTime);
	}
	
	boolean updateGameTime()
	{
		gameTime = nextUpdateTime + DEPLOY_TIME;			
		clientsTime = gameTime; // + GameRoom.DELAY_TIME;
		nextUpdateTime += GAME_UPDATE_DELTA_TIME;
		
		if(gameTime >= END_GAME_TIME)
		{
			finishGameOnTime();
			return false;
		}			
		return true;
	}
	
	public int handleCreatureGameData(ArrayList<String> segments, Player player, long timeOfSending) // in Lobby
	{
		//String lastSegment = segments.get(segments.size()-1);
		//System.out.println("Time at player " + player.playerIndex + " : " + lastSegment);
		
		int copies = 1;
		int copiesCreated = 0;
		
		while(copiesCreated < copies)
		{
//			for(String segment : segments)
//			{
//				System.out.println("*** " + segment);
//			}
			
			Creature creature = createCreature(segments, player, timeOfSending);
//			System.out.println(
//					"Name: " + creature.acronym + 
//					" ID: " + creature.id + 
//					" X: " + creature.pos.x + 
//					" Y: " + creature.pos.y);
			copies = creature.copies;
			//Lobby.creaturesToAddLobby.add(creature);
			player.creaturesToAddTrans.addToInnerList(creature);
			copiesCreated++;

			//System.out.println("Adding creature TO creaturesToAddLobby of player: " + player.playerIndex);
		}
		return copies;
	}
	
	public int handleSpellGameData(ArrayList<String> segments, Player player, long time) // in Lobby
	{
		int copies = 1;
		Spell spell = createSpell(segments, player, time);
		if(spell.timeOfCasting < nextUpdateTime)
			spell.timeOfCasting = nextUpdateTime;
		player.spellsToAddTrans.addToInnerList(spell);
		//System.out.println("Adding spell TO spellsToAddLobby of player: " + player.playerIndex);		
		return copies;
	}
	
//	static void sendCrap(Player player) 
//	{
//		player.sendData(Constants.CRAP_KEY);
//		try {
//			Thread.sleep(5);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//	}

	public void addToPlayersData() 
	{
		long timeStamp = clientsTime;
		if(!sentKings)
			timeStamp = -gameStartDelay;
		
		for(Player player : players)
		{
			player.dataTimestamps.add(timeStamp);
			String time = 
					Constants.GAME_TIME_KEY + 
					Long.toString(timeStamp) + 
					Constants.GAME_SEPERATOR;
			
			player.Data = player.Data.concat(time);
		}
		//sentToClient
		parseCreaturesData();
		parseSpellsData();
		
		for(Player player : players)
		{
			addManaData(player);
			player.Data = player.Data.concat(player.cardData);
			player.cardData = "";
			player.Data = player.Data.concat(Constants.SEMI_COLON_SEPERATOR);
		}
	}
	
	//IG0.10
	//IG0.11
	//IG0.12
	
	//IG1.1012
	//IG1.11
	//IG1.12
	
	
	public void sendDataToPlayers() 
	{
		Player player = players.get(0);
		if(player.Data!="")
		{
			sendDataToPlayer(player);
			player.Data="";		
		}
		player = players.get(1);
		if(player.Data!="")
		{
			sendDataToPlayer(player);
			player.Data="";
		}
	}
	
	void sendDataToPlayer(Player player)
	{ 
//		long timestamp = (Main.serverTime - startGameTime);
//		player.sendData(Constants.TIME_KEY + Constants.FIELD_SEPERATOR + timestamp);		
		player.sendData(player.Data);

		//if(Constants.clientTimingDebug)
		//	System.out.println("Sending to player: " + player.playerIndex + " : " + player.Data);

		//		sendPing(player);
	}
	
	public void drawFirstHand()
    {
		if(!firstHandDrawn)
		{
			for(int i=0; i<players.size(); i++)
			{
				Player player = players.get(i);
				for(int j=0; j<NUM_CARD_INITIAL; j++)
				{
					drawCard(player, TimeOfFirstHandDrawing);
				}		
				player.timeOfNextDraw = TIME_BETWEEN_DRAWS;
				firstHandDrawn = true;
			}	
		}		
    }
	
    public void drawCards()
    {
    	for(int i=0; i<players.size(); i++)
		{
			Player player = players.get(i);
			if(gameTime> player.timeOfNextDraw)
			{
				drawCard(player, clientsTime);
				player.timeOfNextDraw += TIME_BETWEEN_DRAWS;
			}
		}
    }
    
	void drawCard(Player player, long time)
	{
		//if(player.cardsDrawn < DECK_SIZE && player.deck.cards.size() > 0)
		if(player.cardsDrawn < DECK_SIZE)
		{
    		//GameCard card = player.deck.cards.get(0);
    		//player.hand.cards.add(card);
    		//System.out.println("Added card to player: " + player.playerIndex);
    		//player.deck.cards.remove(0);
    		player.cardData = player.cardData.concat(parseCardData("GS", player, time));	    		
    		player.cardsDrawn++;	    	
		}
	}
    
    public void spawnMinions()
    {
    	for(Player player : players)
    	{
    		if(gameTime> player.timeOfNextMinion)
    		{			
    			spawnMinions(player);
    			player.timeOfNextMinion += player.effectiveTimeBetweenMinions;
    		}	
    	}	
    }
	
	void spawnMinions(Player player)
	{	
		spawnMinion(player, Constants.MINION_LEFT);
		spawnMinion(player, Constants.MINION_RIGHT);
	}
	
	void spawnMinion(Player player, String leftOrRight)
	{
    	ArrayList<String> segments = new ArrayList<>();
    	segments.add(Constants.CREATURE_KEY);
    	segments.add(Constants.CR_MINION);
    	segments.add("");
    	segments.add(leftOrRight);
    	Creature creature = createCreature(segments, player);
    	player.creatures.put(creature.id, creature);
	}
	
	/*void addCardData(GameCard gameCard, Player player,long time) { 
		player.cardData = player.cardData.concat(parseCardData(gameCard, player, time));
	}*/
	
	public String parseCardData(String cardName, Player player,long timeStamp) 
	{	
		if(!sentKings)
			timeStamp = 0;
		String time = Long.toString(timeStamp);		
		//String name = gameCard.Name;
		String cardData = Util.addColumns(Constants.DRAW_CARD_KEY, cardName, time);
		
		return cardData;
	}
    
//	void addMana()
//	{
//		for(int i=0; i<players.size(); i++)
//		{
//    		Player player = players.get(i);
//    		
//    		player.mana += (gameTime - player.timeLastAddedMana)/MANA_GROWTH_TIME;
//    		if (player.mana >10)
//    			player.mana = 10;
//    		player.timeLastAddedMana = gameTime;
//    		//if(gameTime > player.timeLastAddedMana)
//    		//{
//    		//	player.mana += 1;
//    		//	player.timeLastAddedMana += MANA_ADDING_TIME;
//    		//}
//		}
//	}
	
	void addManaData(Player player) 
	{ 
		// Sending each player the mana of his opponent
		while(getOpp(player).ManaTimes.size() > 0)
		{
			player.Data = player.Data.concat(parseManaData(getOpp(player)));			
		}		
	}

	public String parseManaData(Player opponent) 
	{
		long timeStamp = opponent.ManaTimes.get(0);
		if(!sentKings)
			timeStamp = 0;
		String time = Long.toString(timeStamp);
		String mana = String.format("%.2f", opponent.ManaValues.get(0));
//		String mana = Float.toString(player.mana);
		String manaData = Util.addColumns(Constants.MANA_UPDATE_KEY, mana, time);
		opponent.ManaValues.remove(0);
		opponent.ManaTimes.remove(0);
		return manaData;
	}
		
	public void parseCreaturesData() 
	{
		parseCreaturesDataPlayer(players.get(0).creatures, 0);
		players.get(0).Data += creaturesDataSelf;
		players.get(1).Data += creaturesDataOther;

		parseCreaturesDataPlayer(players.get(1).creatures, 1);
		players.get(1).Data += creaturesDataSelf;
		players.get(0).Data += creaturesDataOther;
	}
	
	public void parseSpellsData() 
	{
		parseSpellsDataPlayer(players.get(0).spells, 0);
		players.get(0).Data += spellsDataSelf;
		players.get(1).Data += spellsDataOther;

		parseSpellsDataPlayer(players.get(1).spells, 1);
		players.get(1).Data += spellsDataSelf;
		players.get(0).Data += spellsDataOther;
	}
    
    public void parseCreaturesDataPlayer(Map<Integer, Creature> creatures, int playerInd) 
    {
    	int addressId;
		int signId;
		creaturesDataSelf = "";
		creaturesDataOther = "";
		
		Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while(it.hasNext()) 
	    {
	    	Map.Entry<Integer, Creature> pair = it.next();
	        int CreatureId = pair.getKey();
	        Creature creature = creatures.get(CreatureId);

	        String id = Integer.toString(creature.id);
	        String name = creature.acronym;    
	       
	        String status = creature.status.toString();
	        String isNextAttackSA = (creature.isNextAttackSA ? "1" : "0");
	        String extraPauseTime = Long.toString(-creature.extraPauseTime);
	        String currentHp = Integer.toString((int)Math.floor(creature.currentHp));
	        System.out.println("@@@ parseCreaturesDataPlayer: " + creature.acronym + " currentHp: " + creature.currentHp);
	        String timeOfBirth;	   
	        
	        if(name.equals(Constants.CR_KING))
	        {
	        	timeOfBirth = Long.toString(creature.timeOfCasting);
	        	//System.out.println("c. King time of casting: " + creature.timeOfCasting);
	        }
	        else
	        	timeOfBirth = Long.toString(creature.timeOfCasting + DEPLOY_TIME);
	        
	        //Player player = players.get(playerInd);	        
	        //String inGameIndex = calculateMsgIndex();
	        
	        String targetID = "";
	        
	        addressId = playerInd;
	        signId = (addressId == 0) ? 1 : -1;
	        targetID = getCreatureID(creature, signId);
//	        System.out.println("Name:");
//	        System.out.println(creature.acronym);
//	        System.out.println("X Position:");
//	        System.out.println(creature.pos.x);
//	        System.out.println("Y Position:");
//	        System.out.println(creature.pos.y);        
	        
	        creaturesDataSelf = creaturesDataSelf.concat(Util.addColumns(						
				Constants.CREATURE_KEY,
				"0",						
				id,
				name,
				Util.numToString(signId*creature.pos.x),
				Util.numToString(signId*creature.pos.y),
				targetID,
				status,
				isNextAttackSA,
				extraPauseTime,
				currentHp,
				timeOfBirth,
				Util.numToString(creature.AsFactor)));

	        addressId = 1-playerInd;
	        signId = (addressId==0) ? 1 : -1;
	        targetID = getCreatureID(creature, signId);
	        
	        creaturesDataOther = creaturesDataOther.concat(Util.addColumns(
	        	Constants.CREATURE_KEY,
				"1",
				id,
				name,
				Util.numToString(signId*creature.pos.x),
				Util.numToString(signId*creature.pos.y),
				targetID,
				status,
				isNextAttackSA,
				extraPauseTime,
				currentHp,
				timeOfBirth,
				Util.numToString(creature.AsFactor)));
	        //it.remove(); // avoids a ConcurrentModificationException
	    }
	}
    
    public void parseSpellsDataPlayer(Map<Integer, Spell> spells, int playerInd) 
    {
    	int addressId;
		int signId;
		spellsDataSelf = "";
		spellsDataOther = "";
		
		Iterator<Map.Entry<Integer, Spell>> it = spells.entrySet().iterator();
	    while(it.hasNext()) 
	    {
	    	Map.Entry<Integer, Spell> pair = it.next();
	        int spellId = pair.getKey();
	        Spell spell = spells.get(spellId);
	        
	        boolean needToSendInit   = (!spell.initSentToClient   && spell.status.equals(Spell.Status.INIT));
	        boolean needToSendActive = (!spell.activeSentToClient && spell.status.equals(Spell.Status.ACT));
	        boolean needToSendFinish = (!spell.finishSentToClient && spell.status.equals(Spell.Status.FIN));
	        
//	        System.out.println(
//	        		"###Status: " + spell.status +
//	        		" GameTime: " + gameTime +
//	        		" initSentToClient: " + spell.initSentToClient +
//	        		" activeSentToClient: " + spell.activeSentToClient +
//	        		" finishSentToClient: " + spell.finishSentToClient);
	        
	        if(needToSendInit || needToSendActive || needToSendFinish || spell.updateNeeded)
	        {	
		        String id = Integer.toString(spell.id);
		        String acronym = spell.acronym;    
		       
		        String status = spell.status.toString();
		        String timeOfBirth;	        
		        
		        timeOfBirth = Long.toString(spell.timeOfCasting + DEPLOY_TIME);
		        
		        addressId = playerInd;
		        signId = (addressId == 0) ? 1 : -1;
		        spellsDataSelf = spellsDataSelf.concat(Util.addColumns(						
					Constants.SPELL_KEY,
					"0",						
					id,
					acronym,
					Util.numToString(signId*spell.pos.x),
					Util.numToString(signId*spell.pos.y),
					status,
					timeOfBirth));

		        addressId = 1-playerInd;
		        signId = (addressId==0) ? 1 : -1;
		        
		        spellsDataOther = spellsDataOther.concat(Util.addColumns(
		        	Constants.SPELL_KEY,
					"1",
					id,
					acronym,
					Util.numToString(signId*spell.pos.x),
					Util.numToString(signId*spell.pos.y),
					status,
					timeOfBirth));
		        
		        if(spell.updateNeeded)
		        	spell.updateNeeded = false;
		        if(needToSendInit)
		        	spell.initSentToClient = true;
		        else if(needToSendActive)
		        	spell.activeSentToClient = true;
		        else if(needToSendFinish)
		        	spell.finishSentToClient = true;
	        }
	    }
	}
    
    String getCreatureID(Creature creature, int signId)
    {
    	String targetID = Integer.toString(creature.target.id);
	    if(creature.status.equals(Creature.Status.MV) &&
	    		(creature.movementStatus != Creature.MovementStatus.CREATURE))
	    {
	    	if(creature.movementStatus == Creature.MovementStatus.LEFT_FLAG)
	    	{
	    		targetID = (signId==1) ? String.valueOf(LEFT_FLAG_KEY) : String.valueOf(RIGHT_FLAG_KEY);
	    	}
	    	else if(creature.movementStatus == Creature.MovementStatus.RIGHT_FLAG)
	    	{
	    		targetID = (signId==1) ? String.valueOf(RIGHT_FLAG_KEY) : String.valueOf(LEFT_FLAG_KEY);
	    	}	        	
	    	else if(creature.movementStatus == Creature.MovementStatus.ENEMY_KING)
	    	{
	    		targetID = String.valueOf(ENEMY_KING_KEY);
	    	}
	    }
	    return targetID;	    
    }
    
    public Player getOpp(Player player)
	{
    	Player opp = (player.equals(players.get(0))) ? players.get(1) : players.get(0);
    	return opp;
	}
	
	public int generateId()
	{
		cr_sp_id++;
		return cr_sp_id;
	}

	public Creature createCreature(ArrayList<String> segments, Player player, long timeOfSending) 
	{
		Creature creature = createCreature(segments, player);
		creature.timeOfSending = timeOfSending;
		if(creature.timeOfCasting < nextUpdateTime)
			creature.timeOfCasting = nextUpdateTime;
		return creature;
	}
	
	public Creature createCreature(ArrayList<String> segments, Player player) 
	{
		Creature creature = null;
		
		//String key = segments.get(0);
		String acronym = segments.get(1);		
		
		if(acronym.equals(Constants.CR_KING))
		{
			int scalar = players.indexOf(player) == 0 ? 1 : -1;
			creature = CardsData.createCreature(
					Constants.CR_KING, 
					generateId(),
					Vector2.multiplyByScalar(KING_0_START_POS, scalar),
					-gameStartDelay,
					player);
			
			//System.out.println("King time of casting: " + creature.timeOfCasting);
			
			creature.status = Creature.Status.IDL;
			//System.out.println("Created king for player " + player.playerIndex);
		}	
		else if(acronym.equals(Constants.CR_MINION))
		{
			int scalar = players.indexOf(player) == 0 ? 1 : -1;
			Vector2 shift = segments.get(3).equals(Constants.MINION_LEFT) ? 
					Vector2.multiplyByScalar(Vector2.right(), MINION_SHIFT) : Vector2.multiplyByScalar(Vector2.right(), -MINION_SHIFT);
			creature = CardsData.createCreature(
					Constants.CR_MINION, 
					generateId(),
					Vector2.multiplyByScalar(Vector2.add(KING_0_START_POS, shift), scalar), 
					gameTime,
					player);
			//System.out.println("Created king for player " + player.playerIndex);
		}
		else if(segments.size() == 6)
		{		
			//if(player.mana>=creature.ManaCost)
			//{
				//String name = segments.get(1);
				//System.out.println("Name: " + name);
			    String accessoryAcronym = segments.get(2);
				float x = new Float(segments.get(3));
				float z = new Float(segments.get(4));
				long castTime = new Long(segments.get(5));
				Vector2 pos = new Vector2(x, z);
				if(players.indexOf(player)==1)
					pos = Vector2.multiplyByScalar(pos, -1);
//				System.out.println(" 3 from player " + player.playerIndex);
				creature = CardsData.createCreature(
						acronym,
						generateId(),
						accessoryAcronym,
						pos,
						castTime,
						player);	
			//}

	    	if(Constants.clientTimingDebug) 
	    	{
	    		//long delta = clientsTime - creature.timeOfCasting;
	    		//System.out.println("Creature Spawned in server with ID: " + creature.id + " after time: " + delta);
	    		System.out.println("Timing: Creature Spawned in server with ID: " + creature.id + " at clients spawnTime: " + creature.timeOfCasting + " at gameTime " + gameTime);
	    	}
		}

		if (creature == null)
			creature = CardsData.createCreature(Constants.INCORRECT_DATA, -1, new Vector2(0, 0), 0, player);
				
//		player.mana -= creature.ManaCost;
//		if(player.mana<0)
//			player.mana =0;
		
		if (creature.acronym.equals(Constants.INCORRECT_DATA))
			System.out.println(Constants.INCORRECT_DATA);
		
		return creature;
	}

	public Spell createSpell(ArrayList<String> segments, Player player, long time) 
	{
		Spell spell = createSpell(segments, player);
		if(Constants.clientTimingDebug) System.out.println("###createSpell: " + spell.status + " GameTime: " + gameTime);		
		
		spell.timeOfSending = time;
		return spell;
	}
	
	public Spell createSpell(ArrayList<String> segments, Player player) 
	{
		Spell spell = null;
		
		//String key = segments.get(0);
		String acronym = segments.get(1);		
		
		if(segments.size() == 6)
		{	
		    String accessoryAcronym = segments.get(2);
			float x = new Float(segments.get(3));
			float z = new Float(segments.get(4));
			long castTime = new Long(segments.get(5));
			Vector2 pos = new Vector2(x, z);
			if(players.indexOf(player)==1)
				pos = Vector2.multiplyByScalar(pos, -1);
//				System.out.println(" 3 from player " + player.playerIndex);
			spell = CardsData.createSpell(acronym,
					generateId(),
					accessoryAcronym,
					pos,
					castTime,
					player);

	    	if(Constants.clientTimingDebug) 
	    	{
	    		//long delta = clientsTime - creature.timeOfCasting;
	    		//System.out.println("Spell Spawned in server with ID: " + creature.id + " after time: " + delta);
	    		System.out.println("Timing: Spell Spawned in server with ID: " + spell.id + " at clients spawnTime: " + spell.timeOfCasting + " at gameTime " + gameTime);
	    	}
		}

		if(spell == null)
			spell = CardsData.createSpell(Constants.INCORRECT_DATA, -1, new Vector2(0, 0), 0, player);
		
		
				
//		player.mana -= creature.ManaCost;
//		if(player.mana<0)
//			player.mana =0;
		
		if(spell.acronym.equals(Constants.INCORRECT_DATA))
			System.out.println(Constants.INCORRECT_DATA);
		
		return spell;
	}
		
	void moveCreaturesToGMAndAddToLists() // in GR
	{
		for(int i=0; i<players.size(); i++)
			MoveCreaturesToGMPlayer(players.get(i));

		numCreaturesAdded = addCreaturesToLists();
	}
	
	void MoveCreaturesToGMPlayer(Player player) // in GR // sync
	{
		player.creaturesToAddGM = player.creaturesToAddTrans.addFromInnerList(player.creaturesToAddGM);
	}
	
	void moveSpellsToGMAndAddToLists() // in GR
	{
		for(int i=0; i<players.size(); i++)
			moveSpellsToGMPlayer(players.get(i));

		numSpellsAdded = addSpellsToLists();
	}
	
	void moveSpellsToGMPlayer(Player player) // in GR // sync
	{
		//int size0 = player.spellsToAddGM.size();
		player.spellsToAddGM = player.spellsToAddTrans.addFromInnerList(player.spellsToAddGM);
		//int size1 = player.spellsToAddGM.size();
//		
		//if(size0 != size1)
//			System.out.println("###Adding spell FROM spellList of player: " + player.playerIndex);
	}
	
//	ArrayList<String> parseSegment(String str) {
//		ArrayList<String> segments = new ArrayList<String>();
//
//		while (str.contains(Util.FIELD_SEPERATOR)) {
//			int index = str.indexOf(Util.FIELD_SEPERATOR);
//
//			String playerDataSegment = str.substring(0, index);
//			segments.add(playerDataSegment);
//			if (str.length() > index + 1) {
//				str = str.substring(index + 1);
//			} else
//				str = "";
//		}
//		if (str.length() > 0)
//			segments.add(str);
//
//		return segments;
//	}
	
	public void deployCreature(Creature creature)
	{
		creature.status = Creature.Status.IDL;
		
		applyCreatureEffect(CreatureEffect.Occurance.ON_DEPLOY, creature);
		
		if(Constants.clientTimingDebug) 
		{
			//long delta = clientsTime - creature.timeOfCasting;
    		//System.out.println("Creature activated in server with ID: " + creature.id + " approximately after: " + delta);
			//System.out.println("Creature activated in server with ID: " + creature.id + " approximately after: " + delta);
			System.out.println("Timing: Creature activated in server with ID: " + creature.id + " at gameTime: " + gameTime);
		}
	}
	
	public void setTargetAndStatus(Creature creature)
    {
    	Player hero = creature.player;
    	Player villain = getOpp(hero);

        //if ((creature.status == Creature.Status.INITIALIZING) && ((GameRoom.timeOfUpdate - creature.timeOfCasting) > DEPLOY_TIME))        	
    	if((creature.status.equals(Creature.Status.INIT)) 
    			&& ((gameTime - creature.timeOfCasting) > DEPLOY_TIME))
    	{
    		deployCreature(creature);
    	}
    	
    	if((creature.status.equals(Creature.Status.STN)) 
    			&& (gameTime > creature.stunFinishTime))
    	{
    		creature.status = Creature.Status.IDL;
    	}

    	if(creature.status.equals(Creature.Status.MV) ||
    			creature.status.equals(Creature.Status.IDL) ||
    			(creature.status == Creature.Status.ATK &&	
    					(creature.target.status.equals(Creature.Status.DEAD) || creature.attackCanceled || creature.isTaunted)))
    	{
    		System.out.println("setTargetAndStatus - id: " + creature.id);
    		creature.resetAttackTime = true;
    		
    		if(creature.status.equals(Creature.Status.ATK))
        		creature.resetAttackTime = false;
    		
    		creature.lastStatus = creature.status;
    		if(villain.creatures.size() > 0)
        		findTargetAndSetStatus(villain.creatures, creature); 
    		
    		setExtraPauseTime(creature);
    		
    		if(creature.status.equals(Creature.Status.ATK) && creature.lastStatus.equals(Creature.Status.ATK))

    		creature.damageDealt = false;
    		creature.attackCanceled = false;
    	}
    }

	void setExtraPauseTime(Creature creature) 
	{
		if(creature.lastStatus.equals(Creature.Status.ATK))
		{
			if(creature.resetAttackTime) // discontinuous attack
			{
				if(creature.damageDealt) // positive extraPauseTime, negative effectiveTimeFromEngage, continue to count up to zero
				{
					creature.effectiveTimeFromEngage = creature.effectiveTimeFromEngage % creature.attackTime - creature.attackTime;
					creature.extraPauseTime = -creature.effectiveTimeFromEngage;
					creature.stopCountAt = 0;
				}
				else // unnecessary extraPauseTime, positive effectiveTimeFromEngage, continue to count up to 0
				{
					creature.effectiveTimeFromEngage = 0;
					creature.extraPauseTime = 0;
					creature.stopCountAt = 0;
				}
			}
			else // continuous attack
			{
				if(creature.damageDealt) // unnecessary extraPauseTime, positive effectiveTimeFromEngage, continue to count
				{
					creature.effectiveTimeFromEngage = creature.effectiveTimeFromEngage % creature.attackTime - creature.attackTime;
					creature.extraPauseTime = 0;
					creature.stopCountAt = -1;
				}
				else // Unnecessary extraPauseTime, positive effectiveTimeFromEngage, continue to count
				{
					creature.effectiveTimeFromEngage = creature.effectiveTimeFromEngage % creature.attackTime;
					creature.extraPauseTime = 0;
					creature.stopCountAt = -1;
				}
			}
		}
		else
		{
			creature.effectiveTimeFromEngage = 0;
			creature.extraPauseTime = 0;
		}
//		System.out.println("))) resetAttackTime: " + creature.resetAttackTime);
//		System.out.println("))) damageDealt: " + creature.damageDealt);
//		System.out.println("))) effectiveTimeFromEngage: " + creature.effectiveTimeFromEngage);
//		System.out.println("))) extraPauseTime: " + creature.extraPauseTime);
//		System.out.println("))) stopCountAt: " + creature.stopCountAt);		
	}
	
	void setExtraPauseTimeStun(Creature creature) 
	{
		System.out.println("WWW with damageDealt: " + creature.damageDealt + ", effectiveTimeFromEngage : " + creature.effectiveTimeFromEngage);
		if(creature.damageDealt) // positive extraPauseTime, negative effectiveTimeFromEngage, continue to count up to zero
		{
			creature.effectiveTimeFromEngage = creature.effectiveTimeFromEngage % creature.attackTime - creature.attackTime;
			creature.extraPauseTime = -creature.effectiveTimeFromEngage;
			creature.stopCountAt = 0;
		}
		else // unnecessary extraPauseTime, positive effectiveTimeFromEngage, continue to count up to 0
		{
			creature.effectiveTimeFromEngage = 0;
			creature.extraPauseTime = 0;
			creature.stopCountAt = 0;
		}
		System.out.println("WWW result: effectiveTimeFromEngage: " + creature.effectiveTimeFromEngage + ", extraPauseTime : " + creature.extraPauseTime);
	}
	
	public void applyCreatureEffect(CreatureEffect.Occurance occurance, Creature creature) // Occurrence, AOE, dmg
	{
		//System.out.println("))) applyCreatureEffect: " + creature.acronym);
		ArrayList<CreatureEffect> effects = creature.getEffects(occurance);
		
		for(CreatureEffect effect : effects)
		{
			applyCreatureEffect(effect, creature);
		}
	}
	
	public void applyCreatureEffect(
			CreatureEffect.Occurance occurance,
			Creature creature,
			Creature target,
			boolean ignoreAOE) // Occurance, dmg
	{
		ArrayList<CreatureEffect> effects = creature.getEffects(occurance);
		
		for(CreatureEffect effect : effects)
		{
			applyCreatureEffectOnTarget(effect, creature, target);
		}
	}
    
    void applyCreatureEffect(CreatureEffect effect, Creature creature) // AOE , dmg
    {
    	switch(effect.targetFocus)
    	{		
		case SELF:
			applyCreatureEffectOnTarget(effect, creature, creature);
			break;
		case SINGLE_TARGET:
			applyCreatureEffectOnTarget(effect, creature, creature.target);
			break;
		case AOE:
			applyCreatureEffectAOE(effect, creature);
			break;
		case NONE:
			break;
		default:
			break;    	
    	}
    }
    
    void applyCreatureEffectOnTarget(CreatureEffect effect, Creature creature, Creature target) // dmg
    {
    	if(!target.status.equals(Creature.Status.DEAD))
    	{
    		switch(effect.type)
        	{
    		case DMG:
    			dealCreatureEffectDamage(target, effect);
    			break;
    		case FIRST_STRIKE:
    			break;		
    		case HEAL:
    			applyHealOnTarget(effect.modifier, target);
    			break;
    		case INVIS:
    			break;
    		case KNOCKBACK:
    			break;
    		case MULT_TARGET:
    			break;
    		case RAISE_SKELETONS:
    			break;
    		case SHIELD:
    			break;
    		case AS:
    			applyAsModifierOnTarget(effect.modifier, effect.duration, target);
    	    	break;
    		case MS:
    			applyMsModifierOnTarget(effect.modifier, effect.duration, target);
    			break;
    		case STUN:
    			applyStunOnTarget(effect.duration, target);
    			break;
    		case TAUNT:
    			applyTauntOnTarget(target, creature); // creature is the target of the taunt!
    			break;		
    		default:
    			break;    	
        	}
    	}
    }
    
    void applyCreatureEffectAOE(CreatureEffect effect, Creature creature)  // dmg
    {
    	boolean isFriendly = effect.targetType.equals(CreatureEffect.TargetType.FRIENDLY);
    	Player targetPlayer = isFriendly ? creature.player : getOpp(creature.player);
    	ArrayList<Creature> targets = findSurroundingCreatures(creature.pos, effect.radius, targetPlayer);	    
    	for(Creature target : targets)
    		applyCreatureEffectOnTarget(effect, creature, target);
    }
    
    public void findTargetAndSetStatus(Map<Integer, Creature> villianCreatures, Creature creature) {
    	
    	System.out.println("findTargetAndSetStatus - id: " + creature.id);
    	
	    int targetFoundIndex = -1;
	    float distanceFound = 0;
	    Creature targetFound;
	    
	    if (creature.isTaunted && !creature.tauntTarget.status.equals(Creature.Status.DEAD))
	    	targetFoundIndex = creature.tauntTarget.id;
	    else if(creature.siege)
	    	targetFoundIndex = getOpp(creature.player).king.id;
	    else targetFoundIndex = searchTarget(villianCreatures, creature);
	    
	    if(targetFoundIndex > -1)
        {
	    	targetFound = (Creature)villianCreatures.get(targetFoundIndex);	    	
	    	if(targetFound == null)
	    		System.out.println("targetFound == null!");
	    	distanceFound = Vector2.magnitude(Vector2.substract(creature.pos, targetFound.pos));	    	
        	if (distanceFound<=creature.range)
        	{
        		creature.target = targetFound;
        		creature.status = Creature.Status.ATK;
        		
        		creature.attackNumSinceEngage = 0;
        		creature.onslaughtCount = 0;
        		creature.nextAttackPrepareTime = 
        				(creature.isNextAttackSA ? 
        						creature.attackPrepareTimeSA + creature.pauseAttackTime
        						: creature.attackPrepareTime + creature.pauseAttackTimeSA);
        		//creature.effectHitCount = 1;
        		//System.out.println("PPP attackClipLength: " + creature.attackClipLength);
            	//System.out.println("!!! attackClipSpeed: " + creature.attackClipSpeed);
            	float attackClipTimeSeconds = creature.attackClipLength / creature.attackClipSpeed; // without pause
            	//System.out.println("!!! attackClipTimeSeconds: " + attackClipTimeSeconds);
            	//System.out.println("!!! attackPauseTimeSeconds: " + creature.attackPauseTimeSeconds);
            	//System.out.println("!!! attackSpeed: " + creature.attackSpeed);
            	//System.out.println("!!! attackTime: " + creature.attackTime);
            	//System.out.println("!!! attackPrepareTime: " + creature.attackPrepareTime);
            	//System.out.println("!!! clip Pount: " + creature.clipPoint);

    			System.out.println("in range " + creature.id);
        	}
        	else if (creature.ms !=Creature.MovementSpeed.IMMOBILE) // aggro but out of range
        	{
        		creature.target = targetFound;
        		creature.status = Creature.Status.MV;
        		
        		creature.resetAttackTime = true;
    			System.out.println("aggro but out of range - !immobile " + creature.id);
        	}
        	else //  aggro but out of range - immobile
        	{
        		creature.target = targetFound;
        		creature.status = Creature.Status.IDL;
        		
        		creature.resetAttackTime = true;
    			System.out.println("aggro but out of range - immobile " + creature.id);
        	}
        }
	    else
	    {
	    	if (creature.ms !=Creature.MovementSpeed.IMMOBILE) // no agro and moving
	    	{
	    		creature.target = creature;
	    		creature.status = Creature.Status.MV;

	    		creature.resetAttackTime = true;
	    		System.out.println("!IMMOBILE " + creature.id);
	    	}
	    	else // no aggro and immobile
	    	{
	    		creature.status = Creature.Status.IDL;
	    		creature.target = creature;
	    		System.out.println("IMMOBILE " + creature.id);
		
	    		creature.resetAttackTime = true;
	    	}
	    }
	    
	    if(creature.status == Creature.Status.MV)
          	setMovementTarget(creature);
	    
	    creature.isTaunted = false;
	    
	    System.out.println("Final Status: " + creature.status);
	    System.out.println("Final Target: " + creature.target.id);
	}

	int searchTarget(Map<Integer, Creature> villianCreatures, Creature creature) {
		float distance = 5000;
        int targetIndex = -1;
	    Iterator<Map.Entry<Integer, Creature>> it = villianCreatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer, Creature> pair = it.next();
	        int CreatureId = pair.getKey();
	        Creature target = villianCreatures.get(CreatureId);
        	if((target.status != Creature.Status.DEAD)
        			&& (target.status != Creature.Status.INIT))
        	{
        		float distanceNow = Vector2.magnitude(Vector2.substract(creature.pos, target.pos));
        		
        		if ((distanceNow < distance) &&
        				(distanceNow < creature.scaledVision))
        		{
        			if((!creature.rangeAttack && !target.flying) || (creature.rangeAttack || creature.flying)) // simple targetting
        			{
        				if(creature.flying) // flying
        				{
        					targetIndex = CreatureId;
                			distance = distanceNow;
        				}
        				else if(creature.rangeAttack &&	(distanceNow <  creature.range)) // range
        				{
        					targetIndex = CreatureId;
                			distance = distanceNow;
        				}
        				else if(!creature.rangeAttack && 
        						((creature.pos.y * target.pos.y >0) || (distanceNow <  creature.range))) // melee
        				{
        					targetIndex = CreatureId;
                			distance = distanceNow;
        				}
        			}
        		}
        	}
	    }
    	System.out.println("Return Target ID: " + targetIndex);
	    return targetIndex;
	}
    
    void setMovementTarget(Creature creature)
    {
    	if(creature.target.equals(creature))
    	{
    		creature.movementStatus=findClosestWalkingPoint(creature);
    	}
    	else
    	{
    		creature.movementStatus = Creature.MovementStatus.CREATURE;
    		
    	}
    }
    
    Creature.MovementStatus findClosestWalkingPoint(Creature creature)
    {
    	int scalar = players.indexOf(creature.player) == 0 ? 1 : -1;
    	if((Vector2.multiplyByScalar(creature.pos, scalar).y < 0) ||
    			creature.flying)
    	{
    		return Creature.MovementStatus.ENEMY_KING;
    	}
    	else
    	{
    		if(creature.pos.x > 0)
    			return Creature.MovementStatus.LEFT_FLAG;
    		else 
    			return Creature.MovementStatus.RIGHT_FLAG;
    	}
    }
    
	void creaturesAttack()
    {
    	for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		playerCreaturesAttack(player.creatures);
    	}
    }
	
	void creaturesApplyDmgAndSE()
    {
    	for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		playerCreaturesApplyDmgAndSE(player.creatures);
    	}
    }
    
	void applyCreaturesHealthRegen()
	{
		for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		playerApplyHealthRegen(player.creatures);
    	}		
	}
	
	void playerApplyHealthRegen(Map<Integer, Creature> creatures) 
    {		
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Creature> pair = it.next();
	        int CreatureId = pair.getKey();
	        Creature creature = creatures.get(CreatureId);
	        applyHealthRegen(creature);	        
	    }
	}

	private void applyHealthRegen(Creature creature) 
	{
		float deltaTimeOver10 = (float)(gameTime-lastUpdateTime)/1000/10;
		float hpToRegen = creature.maxHp * Util.applyPercent(creature.healthRegen * deltaTimeOver10);
		//                                                            -0.3               0.01
//		System.out.println("@@@ applyHealthRegen " + creature.acronym + " creature.healthRegen: " + creature.healthRegen + " hpToRegen: " +  hpToRegen);
//		System.out.println("@@@ gameTime " + gameTime + " lastUpdateTime: " +  lastUpdateTime + " deltaTimeOver10: " + deltaTimeOver10);		
		
		creature.currentHp += hpToRegen;
		//System.out.println("@@@ " + creature.acronym + " deltaTimeOver10: " + deltaTimeOver10 + " hpToRegen: " + hpToRegen + " healthRegen: " + creature.healthRegen);
		
		if(creature.currentHp > creature.maxHp)
			creature.currentHp = creature.maxHp;
	}

	public void playerCreaturesAttack(Map<Integer, Creature> creatures) 
    {
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Creature> pair = it.next();
	        Creature creature = pair.getValue();
	        
	        updateEffectiveTime(creature);
			if(creature.status.equals(Creature.Status.ATK) && !creature.attackCanceled)
			{
				attack(creature); 
			}
	    }
	}
	
	public void playerCreaturesApplyDmgAndSE(Map<Integer, Creature> creatures) 
    {
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Creature> pair = it.next();
	        Creature creature = pair.getValue();
	        
	        applyDmgAndSE(creature);
	    }
	}
	
	void updateEffectiveTime(Creature creature) 
	{		
		long deltaTime = gameTime - lastUpdateTime;
		long deltaEffectiveTime = (long)((float)deltaTime * creature.AsFactor);
		
		if(!creature.status.equals(Creature.Status.ATK))
		{
			if(creature.effectiveTimeFromEngage + deltaEffectiveTime <= creature.stopCountAt)
			{
				creature.effectiveTimeFromEngage += deltaEffectiveTime;
				creature.extraPauseTime = -creature.effectiveTimeFromEngage;
			}
		}
		else
		{
			creature.effectiveTimeFromEngage += deltaEffectiveTime;
		}	
		
//		System.out.println("))) UPDATE effectiveTimeFromEngage: " + creature.effectiveTimeFromEngage);
//		System.out.println("))) UPDATE extraPauseTime: " + creature.extraPauseTime);
	}

	public void playerApplySpellsEffect(Map<Integer, Spell> spells) 
    {
	    Iterator<Map.Entry<Integer, Spell>> it = spells.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Spell> pair = it.next();
	        int spellId = pair.getKey();
	        Spell spell = spells.get(spellId);
	        if(spell.status == Spell.Status.ACT)
	        	applySpellEffectOverTime(spell);
	    }
	}
    
	void applySpellEffectOverTime(Spell spell)
	{
		long deltaTime = gameTime - lastUpdateTime;
		if(deltaTime > gameTime - spell.activationTime)     // if we are in the first update of the spell
			deltaTime = gameTime - spell.activationTime;
		else if(gameTime + deltaTime > (spell.activationTime + spell.duration)) // if we are in the last update of the spell
		{
			//long finishTime = spell.timeOfCasting + (long)(spell.duration);			
			deltaTime =  spell.activationTime + spell.duration - gameTime;
		}
		if(deltaTime < 0)
		{
			//System.out.println("@@@ Attempting to apply spell effect after it was already over. Status: " + spell.status);
			return;
		}			
		
		Player targetPlayer = spell.Type.equals(Spell.TargetType.ENEMY) ? getOpp(spell.player) : spell.player; 
		
		ArrayList<Creature> creatures = findSurroundingCreatures(spell.pos, spell.radius, targetPlayer);
    	
		//System.out.println("Found Creatures: " + creatures.size());
		for(Creature creature : creatures)
		{			
			Iterator<Map.Entry<Effect,Float>> it = spell.EffectsPerSec.entrySet().iterator();
		    while (it.hasNext()) {
		    	Map.Entry<Effect,Float> pair = it.next();	       
		        Effect effect = pair.getKey();
		        float modifier = pair.getValue() * deltaTime;
//		        System.out.println("id: " + creature.id);
//		        System.out.println("effect: " + effect);
//		        System.out.println("modifier: " + modifier);
//		        System.out.println("deltaTime: " + deltaTime + " gameTime: " + gameTime + " lastUpdateTime: " + lastUpdateTime + " spell.timeOfCasting: " + spell.timeOfCasting);
		        applySpellEffectOnCreature(effect, modifier, creature);
		    }
		}
	}
	
	void applySpellEffectOnCreature(Spell.Effect effect, float modifier, Creature target)
	{
		switch(effect)
		{
		case DMG:
			dealSpellDamage(modifier, target);
			break;
		case HEAL:
			applyHealOnTarget(modifier, target);
			break;		
		case PULL:
			applySpellPull(modifier, target);
			break;
		case PUSH:
			applySpellPush(modifier, target);
			break;
		case SECRET:
			applySpellSecret(modifier, target);
			break;
		case SLOW:
			applySpellSlow(modifier, target);
			break;
		case STUN:
			applySpellStun(modifier, target);
			break;
		default:
			break;		
		}
	}
    
    public void applyHealOnTarget(float heal, Creature target)
    {
    	target.currentHp += heal;
    	System.out.println("@@@ applyHealOnTarget " + target.acronym + " heal: " + heal);
        if(target.currentHp > target.maxHp)
        	target.currentHp = target.maxHp;
    }
    
    public void applyAsModifierOnTarget(float modifier, long time, Creature target)
    {
    	target.AsChanges.add(modifier);
    	target.finishTimesAsChange.add(gameTime + time);
    }
    
    public void applyMsModifierOnTarget(float modifier, long time, Creature target)
    {
    	target.MsChanges.add(modifier);
    	target.finishTimesMsChange.add(gameTime + time);
    }
    
    public void applyStunOnTarget(long time, Creature target)
    {
    	System.out.println("WWW apply stun on " + target.id + " for " + (time/1000) + " sec, GameTime :" + gameTime);    	
    	target.status = Creature.Status.STN;
    	setExtraPauseTimeStun(target);
    	target.stunFinishTime = Math.max(target.stunFinishTime, gameTime + time);
    }
    
    public void applyTauntOnTarget(Creature target, Creature tauntTarget)
    {
    	System.out.println("WWW apply TAUNT on " + target.id + " to creature id: " + target + " sec, GameTime :" + gameTime);    	
    	target.isTaunted = true;
    	target.tauntTarget = tauntTarget;
    }
    
    public void applySpellPull(float distance, Creature target)
    {      		
    	
    }
    
    public void applySpellPush(float distance, Creature target)
    {      		
    	
    }
    
    public void applySpellSecret(float preciousness, Creature target)
    {      		
    	
    }
    
    public void applySpellSlow(float slow_modifier, Creature target)
    {      		
    	
    }
    
    public void applySpellStun(float stun_modifier, Creature target)
    {      		
    	
    }
	
    void attack(Creature creature) 
    {
    	float actualRange = checkRange(creature);
    	if(actualRange < (creature.range + creature.extraRangeOneHit))
    	{
    		if(creature.damageDealt)
    		{
    			if(creature.effectiveTimeFromEngage >
						creature.attackNumSinceEngage * creature.attackTime + creature.attackTime)
    			{
    				prepareNextAttack(creature);
    				if(actualRange > creature.range + creature.extraRangeContinuous)
    				{
    					creature.attackCanceled = true;
//    					System.out.println("GGG creatureID: " + creature.id + " got out of range at GameTime :" + gameTime);
//    		    		System.out.println("GGG range: " + creature.range);
//    		    		System.out.println("GGG actualRange: " + actualRange);
//    		    		System.out.println("effectiveTimeFromEngage: " + creature.effectiveTimeFromEngage);
        			}
    				creature.damageDealt = false;
    			}
    		}

    		if(!creature.damageDealt)
    		{
    			if(creature.effectiveTimeFromEngage >
    					creature.attackNumSinceEngage * creature.attackTime + creature.nextAttackPrepareTime)
    			{				
    				enqueAttack(creature);
    				creature.damageDealt = true;
    				updateHitCount(creature);
    			}
    		}
    	}
    	else
    	{
    		creature.attackCanceled = true;
//    		System.out.println("GGG creatureID: " + creature.id + " got out of extra-range at GameTime :" + gameTime);
//    		System.out.println("GGG range: " + creature.range + " extraRange :" + creature.extraRangeOneHit);
//    		System.out.println("GGG actualRange: " + actualRange);
//    		System.out.println("effectiveTimeFromEngage: " + creature.effectiveTimeFromEngage);
        	
    	}
    }
    
    float checkRange(Creature creature)
    {
    	float range =Vector2.distance(creature.pos, creature.target.pos);
		return range;
    }
    
    void enqueAttack(Creature creature)
    {
//    	System.out.println("WWW enque attack of " + creature.id + "GameTime :" + gameTime);
    	if(!creature.isNextAttackSA)
			creature.timeOfDmgs.add(gameTime + creature.calculateDamageTime(creature.pos, creature.target.pos));
		else
		{
			creature.timeOfSAs.add(gameTime + creature.calculateDamageTime(creature.pos, creature.target.pos));
			//creature.indexOfSAs.add(arg0)
		}
    }
    
    void prepareNextAttack(Creature creature)
    {
		creature.attackNumSinceEngage++;
		
    	creature.nextAttackPrepareTime = 
				(creature.isNextAttackSA ? 
						creature.attackPrepareTimeSA + creature.pauseAttackTime
						: creature.attackPrepareTime + creature.pauseAttackTimeSA);
    }
			
    void updateHitCount(Creature creature)
    {
		creature.effectHitCount++;
		
		creature.isNextAttackSA = false;
    	if(creature.everyXattacks > 0 &&
    			creature.effectHitCount % creature.everyXattacks == 0)
		{
			creature.isNextAttackSA = true;
		}
    	//System.out.println("MAVET - " + creature.id + " isNextAttackSA: " + creature.isNextAttackSA);
		if(creature.onslaughtCount < creature.ONSLAUGHT_CAP)
			creature.onslaughtCount++;
		
//		System.out.println("***: Start next attack: " + creature.effectHitCount + " gametime: " + gameTime);
    }
    
    void applyDmgAndSE(Creature creature)
    {
    	for(int i=0; i < creature.timeOfDmgs.size(); i++)
		{
			if(gameTime >= creature.timeOfDmgs.get(i))
			{
				if(creature.attackFocus == Creature.AttackTargetFocus.SINGLE_TARGET)
				{
					dealCreatureDamage(creature, creature.target);
					applyCreatureEffect(CreatureEffect.Occurance.ON_HIT, creature, creature.target, true); // ignoreAOE
				}
				else if(creature.attackFocus == Creature.AttackTargetFocus.AOE)
				{
					applyCreatureAreaDamage(creature);
				}
				
				System.out.println(creature.acronym + " dealing " + creature.damage + " to " + creature.target.acronym);
				creature.timeOfDmgs.remove(i);		
			}
		}
    	
    	for(int i=0; i < creature.timeOfSAs.size(); i++) // only on hit and x-attacks
		{
			if(gameTime >= creature.timeOfSAs.get(i))
			{
				ArrayList<CreatureEffect> effects = creature.getEffects(CreatureEffect.Occurance.EVERY_X_ATTACKS);
				if(!effects.isEmpty())
					applyCreatureEffect(CreatureEffect.Occurance.EVERY_X_ATTACKS, creature);
				else
					applyCreatureEffect(CreatureEffect.Occurance.ON_HIT, creature);
				
				creature.timeOfSAs.remove(i);				
			}
		}
    }
    
    public void applyCreatureAreaDamage(Creature creature)
    {    	
    	ArrayList<Creature> creatures = findSurroundingCreatures(creature.target.pos, creature.areaDamageRadius, creature.target.player);
    	
    	for(Creature target : creatures)
    	{
        	if(target.status != Creature.Status.INIT)
        	{
        		dealCreatureDamage(creature, target);
        		applyCreatureEffect(CreatureEffect.Occurance.ON_HIT, creature, creature.target, true); // ignoreAOE
        	}
    	}
    }
    
    void dealTrueDamage(float damage, Creature target)
    {
    	target.currentHp -=  damage;           	
        
    	if(target.currentHp <= 0)
        	killCreature(target);	
    }
    
    void applyLifeSteal(float extraHealth, Creature creature)
    {
    	creature.currentHp +=  extraHealth;    	
    	System.out.println("@@@ applyLifeSteal " + creature.acronym + " extraHealth: " + extraHealth);
    	
    	if(creature.currentHp > creature.maxHp)
    		creature.currentHp = creature.maxHp;
    }
    
    ArrayList<Creature> findSurroundingCreatures(Vector2 targetPos, float radius, Player targetedPlayer)
    {
    	ArrayList<Creature> creatures = new ArrayList<>();
    	
	    Iterator<Map.Entry<Integer,Creature>> it = targetedPlayer.creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Creature> pair = it.next();
	        //int CreatureId = (Integer) pair.getKey();
	        Creature creature = pair.getValue();
	        
	        if(Vector2.distance(targetPos, creature.pos) <= radius)
	        	creatures.add(creature);
	    }
    	
    	return creatures;
    }
    
    void dealCreatureDamage(Creature creature, Creature target)
    {   
    	float onslaughtModifier = Util.addPercent(creature.onslaughtBonus * creature.onslaughtCount);    	
    	float firstStrikeModifier = 1;
    	if(creature.onslaughtCount ==0)
    		firstStrikeModifier *= Util.addPercent(creature.firstStrikeBonus);
    	float firstDodgeModifier = 1;
    	if(creature.onslaughtCount ==0)
    		firstDodgeModifier *= Util.subtractPercent(target.firstDodgeBonus);    	
    	float damageReduction = getDamageReduction(creature, target);
    	
//    	System.out.println("creature.damage: " + creature.damage);
    	System.out.println("onslaughtModifier: " + onslaughtModifier);
//    	System.out.println("firstStrikeModifier: " + firstStrikeModifier);
//    	System.out.println("firstDodgeModifier: " + firstDodgeModifier);
//    	System.out.println("damageReduction: " + damageReduction);
    	
    	float effectiveDamage = 
    			creature.damage 
    			* onslaughtModifier
    			* firstStrikeModifier
    			* firstDodgeModifier
    			* damageReduction;
    	
    	System.out.println("### " + creature.acronym + " dealing " + effectiveDamage + " to " + target.acronym);
    	
    	dealTrueDamage(effectiveDamage, target);
    	applyLifeSteal(effectiveDamage * creature.lifeSteal, creature);
    }
    
    void dealSpellDamage(float damage, Creature target)
    {    	
    	float effectiveDamage = damage * target.spellDamageReduction;
    	dealTrueDamage(effectiveDamage,target);
    	//System.out.println("@@@ " + target.acronym + " effectiveDamage: " + effectiveDamage + " spellDamageReduction: " + target.spellDamageReduction);
    }

    void dealCreatureEffectDamage(Creature target, CreatureEffect effect)
    {
    	float damageReduction = target.abilityDamageReduction;    	
    	float effectiveDamage = effect.modifier * damageReduction;    	
    	//System.out.println("### " + target.acronym + " dealt " + effectiveDamage + " by " + effect.type);
    	
    	dealTrueDamage(effectiveDamage, target);
    }
    
    float getDamageReduction(Creature creature, Creature target)
    {
    	float damageReduction = 1;
		if(creature.attackType.equals(Creature.AttackType.NORMAL))
			damageReduction = target.normalDamageReduction;
		else if(creature.attackType.equals(Creature.AttackType.MAGIC))
			damageReduction = target.magicDamageReduction;
		
		return damageReduction;
    }
    
    void killCreature(Creature creature)
    {
    	if(creature.acronym == Constants.CR_KING)
    		finishGame(creature);
    
    	//Player player = creature.player;    
    	creature.status = Creature.Status.DEAD;
    	creature.timeOfDeath = gameTime;
    	applyCreatureEffect(CreatureEffect.Occurance.ON_DEATH, creature);
    	//player.creatures.remove(creature.id);
	    System.out.println("Creature dead " + creature.id + " time " + gameTime); //Debugging
    }
    
    void finishSpell(Spell spell)
    {
    	spell.status = Spell.Status.FIN;
    	//System.out.println("###finishSpell: " + spell.status + " GameTime: " + gameTime);
    }
	
    void finishGame(Creature kingDied)
    {
    	System.out.println("player" + kingDied.player.playerIndex + "lost #gg");
    	kingDied.player.isVictorious = false;
      	getOpp(kingDied.player).isVictorious = true;
    	gameEnded = true;
    }
    
    void finishGameOnTime()
    {
    	System.out.println("Time's up! Finishing game");
    	for(Player player : players)
    	{
    		player.isVictorious = false;    		
    	}
    	gameEnded = true;
    }
    
    public void sendEndGameNotice()
    {
    	players.get(0).sendData(Constants.END_GAME + Constants.FIELD_SEPERATOR + players.get(0).isVictorious);
		players.get(1).sendData(Constants.END_GAME + Constants.FIELD_SEPERATOR + players.get(1).isVictorious);
    }
    
    void clearPlayersData()
    {
    	for(Player player : players)
    	{
    		player.clearGameData();
    	}
    }
    
    void creaturesMove()
    {
    	for(int i=0; i < players.size(); i++)
    	{
    		Player player = players.get(i);
    		movePlayerCreatures(player.creatures);
    	}
    }
    
    public void movePlayerCreatures(Map<Integer, Creature> creatures) 
    {
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer,Creature> pair = it.next();
	        int CreatureId = pair.getKey();
	        Creature creature = creatures.get(CreatureId);
			//if((creature.status == Creature.Status.MOVING)&&(!creature.Name.equals("KG")))
	        if(creature.status == Creature.Status.MV)	        		
			{
				moveCreature(creature);
				//System.out.println("Moved " + creature.id);
			}
	        //checkAttack(creature);
	        //it.remove(); // avoids a ConcurrentModificationException
	    }
	}
    
    void moveCreature(Creature creature)
    {
    	Vector2 target = Vector2.zero();
    	Vector2 direction = Vector2.zero();
    	Vector2 displacement = Vector2.zero();
    	if(creature.movementStatus.equals(Creature.MovementStatus.CREATURE))
    	{
    		target = creature.target.pos;
    		displacement = Vector2.substract(target, creature.pos);
    		direction = Vector2.normalize(displacement);
    	}
    	else if(creature.movementStatus.equals(Creature.MovementStatus.LEFT_FLAG))
    	{
    		target =Vector2.add(LANE_CENTER_LEFT, Vector2.multiplyByScalar(Vector2.forward(), -Math.signum(creature.pos.y) * DELTA_LOOKAT_FLAG ));
    		displacement = Vector2.substract(target, creature.pos);
    		direction = Vector2.normalize(new Vector2(displacement.x,displacement.y/2));
    	}
    	else if(creature.movementStatus.equals(Creature.MovementStatus.RIGHT_FLAG))
    	{
    		target = Vector2.add(LANE_CENTER_RIGHT, Vector2.multiplyByScalar(Vector2.forward(), -Math.signum(creature.pos.y) * DELTA_LOOKAT_FLAG ));
    		displacement = Vector2.substract(target, creature.pos);
    		direction = Vector2.normalize(new Vector2(displacement.x,displacement.y/2));
    	}
    	else if(creature.movementStatus.equals(Creature.MovementStatus.ENEMY_KING))
    	{
    		int scalar = players.indexOf(creature.player) == 0 ? -1 : 1;
    		Vector2 EnemyKingPosition= Vector2.multiplyByScalar(KING_0_START_POS, scalar);
    		target = EnemyKingPosition;
    		displacement = Vector2.substract(target, creature.pos);
    		direction = Vector2.normalize(new Vector2(displacement.x,displacement.y));
    	}
    	float deltaTime = gameTime - lastUpdateTime;
    	if(deltaTime > 0)
    	{
        	float deltaDistance = 
        			creature.movementSpeed * 
        			creature.MsFactor * 
        			deltaTime / 1000;
        	
            Vector2 movement = Vector2.multiplyByScalar(direction, deltaDistance);        
            Vector2 newPosition = Vector2.add(creature.pos, movement);
//            System.out.println("PPPPP  gameTime = " + gameTime);
//            System.out.println("lastUpdateTime = " + lastUpdateTime);
//            System.out.println("deltaTime = " + deltaTime);
//            System.out.println("movementSPITZ = " + creature.movementSpeed);            
//            System.out.println("deltaDistance = " + deltaDistance);
                        
            if(Math.signum(creature.pos.x - target.x) != Math.signum(newPosition.x - target.x))
            {
            	movement.x = target.x - creature.pos.x;
            	movement.y = (float) Math.sqrt(deltaDistance - Math.pow(movement.x,2f));
            	newPosition = Vector2.add(creature.pos, movement);
            }
            creature.pos = newPosition;
    	}
    }
    
    void setCreatureTargets()
    {
    	for(int i=0; i<players.size(); i++)
    	{
    		Player player = players.get(i);
    		setPlayerCreatureTargets(player.creatures);
    	}
    }

    public void setPlayerCreatureTargets(Map<Integer, Creature> creatures) {
	    Iterator<Map.Entry<Integer, Creature>> it = creatures.entrySet().iterator();
	    while (it.hasNext()) 
	    {
	    	Map.Entry<Integer, Creature> pair = it.next();
	        //int CreatureId = pair.getKey();
	        Creature creature = pair.getValue();
	        if(creature.status != Creature.Status.DEAD)
	        {
	        	adjustAsFactor(creature);
	        	adjustMsFactor(creature);
	        	
		        if(creatures.containsValue(creature.target))
		        {
		        	if(creature.status != Creature.Status.ATK || 
		        			creature.attackCanceled ||
	    				creature.target.status == Creature.Status.DEAD)
		    		{
		    			//System.out.println("setTarget " + creature.id);
		    			setTargetAndStatus(creature); 
		    			creature.attackCanceled = false;
		    		}
		        }
		        else
		        {
		        	//System.out.println("setTarget " + creature.id);
		        	setTargetAndStatus(creature); 
		        }        
	        }
	    }
	}
    
    void adjustAsFactor(Creature creature)
    {
    	if(!creature.finishTimesAsChange.isEmpty())
    	{
    		for(int i=0; i<creature.finishTimesAsChange.size(); i++)
    		{
    			if(gameTime > creature.finishTimesAsChange.get(i))
    			{
    				creature.finishTimesAsChange.remove(i);
    				creature.AsChanges.remove(i);
    			}
    		}
    	}
    	creature.AsFactor = 1f;
    	if (!creature.finishTimesAsChange.isEmpty())
    	{
    		for(int i=0; i < creature.finishTimesAsChange.size(); i++)
    		creature.AsFactor *= creature.AsChanges.get(i);
    	}
    }
    
    void adjustMsFactor(Creature creature)
    {
    	if(!creature.finishTimesMsChange.isEmpty())
    	{
    		for(int i=0; i<creature.finishTimesMsChange.size(); i++)
    		{
    			if(gameTime > creature.finishTimesMsChange.get(i))
    			{
    				creature.finishTimesMsChange.remove(i);
    				creature.MsChanges.remove(i);
    			}
    		}
    	}
    	creature.MsFactor = 1;
    	if (!creature.finishTimesMsChange.isEmpty())
    	{
    		for(int i=0; i < creature.finishTimesMsChange.size(); i++)
    		creature.MsFactor *= creature.MsChanges.get(i);
    	}
    }
    
    void updateManaBuffer(Player player, long time, float mana) 
    {    	 
    	player.ManaValues.add(mana);
    	player.ManaTimes.add(time);
    }
} 
